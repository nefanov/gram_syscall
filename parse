import sys
import routines
from orderedset import OrderedSet


#  rule checkers

class proc:

    def __init__(self, p, g, s):
        self.g = g
        self.s = s
        self.p = p


# every match function returns list of [the name [args] of syscall, reconstructed Left side of rule (proc-terminal)]
# for example, ['fork', [1,1,1]]


def match_fork(p=proc('1','1','1'), c=proc('1','1','1')):
    if p.g == c.g == p.s == c.s:
        return ['fork', [p.p, p.g, p.s]]
    return ['nop', []]

#context-dependent check: session with c.s number should exist

def match_setsid(p=proc('1','1','1'), c=proc('1','1','1'), context_dep=False, session_list=[]):
    if c.s == c.g == c.p:
        if not c.s == p.s:
            return ['setsid', [c.p, p.g, p.s]]

    if not context_dep==False:
        if not c.s == p.s and not c.g in session_list:
            print "parsing error: session "+str(c.s)+" not found"
            quit()

    return ['nop', []]


# setpgid is context-dependent rule
def match_setpgid(p=proc('1','1','1'), c=proc('1','1','1'), context_dep=False, group_list=[]):
    # the most simple case: setpgid(0,0) - set new group and become group leader
    if c.p == c.g and not c.s == c.p:

        return ['setpgid('+ str(c.g) + ', ' + str(c.g)+')', [c.p, p.g, c.s]]

    # the another case is more complex and context-dependent: the group should be checked: setpgid(0,pgid) && exists(pgid,pgid,sid)
    #  - add itself to some group

    if not context_dep==False:
        if c.g in group_list and not c.g == p.g and c.s == p.s:
            return ['setpgid(self,' + p.s + ')', [c.p, p.g, c.s]]

    return ['nop',[]]


#  context-free patterns match
def cf_patterns_match(parent=['1','1','1'], child=['2','1','1']):
    p = proc(parent[0], parent[1], parent[2])
    c = proc(child[0], child[1], child[2])
    proc_rules_list = [match_setsid, match_setpgid]
    for func in proc_rules_list:
        if func(p, c)[0] != 'nop':
            return func(p, c)

    return ['nop', []]

'''
def reconstruct(proc_chain=[]):

    return proc_chain
'''
'''
def attach(list ):

    return Node
'''


# terminal->nonterminal stack
# bp, sp, lr are indexes, lr are unused now
class stack:

    def __init__(self):
        self.bp = 0
        self.sp = 0
        self.lr = 0
        self.data = list()

    def __getitem__(self,item):
        return self.data[item]

    def __setitem__(self, key, value):
        self.data[key] = value


# push the val to analyser's stack
    def push(self, val):
        self.data.append(val)
        self.sp += 1

# pop the val and return, without bp unwinding
    def pop(self):
        self.sp -= 1
        return self.data.pop()

# call: save the bp into lr and
    def call(self):
        self.lr = self.bp
        self.bp = self.sp

# unwind the bp
    def unwind(self):
        self.bp = self.lr
'''
    def represent(self,  children_from, parent=routines.Node("1 1 1")):
        for i in xrange(children_from, len(parent.data)):
'''



#def match_pattern(, ):


class machine:

    def __init__(self):
        self.stack = stack()
        self.state = 'init'


# parser is a left context-free parser with context-dependent post-check (In compiler-like SA manner).
# 1) context-free upwarding until ']' with non-empty stack. Then trusted (context-free) downwarding on stackframe with reconstruction.
# 2) after the whole string is ended - full untrusted (context-dependent) process check.

#'optimized' should solve the problem of non-optimal setpgids (see example 1 1 1 -> 2 2 1 -> 3 1 1)


def parse(argst="100 101 102 [ ]", optimized=False):
    line = argst.split(' ')
    pidset = OrderedSet()
    parser = machine()

    num = 0
    while num in xrange(len(line)):
        if (line[num]).isdigit() and (line[num+1]).isdigit() and (line[num+2]).isdigit():
            parser.state = 'proc'
            parser.stack.push([[line[num], line[num+1], line[num+2]]])
            num += 3

            try:
                pidset.index(int(line[num-3]))
            except ValueError:
                pidset.add(int(line[num-3]))

            else:
                print "Parsing error: pid duplicate"
                break

        if line[num] == '[':
            if parser.state == 'proc':
                parser.state = 'call'
                parser.stack.push([parser.stack.bp])
                parser.stack[-1].append([])
#                print "bp_old" + str(parser.stack.bp)
#                print "bp_new" + str(parser.stack.sp - 1)
#                print parser.stack.data
                parser.stack.bp = parser.stack.sp - 1

        elif line[num] == ']':

            if parser.stack.sp - parser.stack.bp == 1:  # leaf-node

                parser.state == 'revert'

                parser.stack.bp = parser.stack[parser.stack.bp][0]

                num += 1
                continue

            else:

                #  not leaf node - visit all of 1st level children
                it = parser.stack.bp
                while it < parser.stack.sp - 1:

                    it += 1

                    print it
                    # check all context rules, then:
                    if not (routines.is_link(parser.stack[it])):
                        inner_it = -1
                        if parser.stack[it+1][0] > parser.stack.bp:
                            it += 1
                            continue
                        #else append the children's basepointers into the list near the parent basepointer
                        # (to handle them in context-dependent downward)
                        parser.stack[parser.stack.bp][1].append(it+1)
                        # log info:
                        print "match " + str(parser.stack[parser.stack.bp-1][inner_it])+" and "+str(parser.stack[it][inner_it])
                        match_res = cf_patterns_match(parser.stack[parser.stack.bp-1][inner_it], parser.stack[it][inner_it])
                        # insert the reconstructed part into the stack on the current child position (left-side)

                        if not match_res[0] == 'nop':
                            # apply the matched pattern: left side of rule reconstruction
                            print "\t match OK: "+str(match_res[0]) + str(match_res[1])
                            parser.stack[it].insert(0, match_res[0])
                            parser.stack[it].insert(0, match_res[1])



                    else:
                        continue

                parser.state == 'revert'
                parser.stack.bp = parser.stack[parser.stack.bp][0]

        else:
            print "Parsing error: " + line[num]
            break

        num += 1
    '''
    it = 0
    while it < len(parser.stack.data):
        if parser.stack.data[it] == -1:
            parser.stack.data.pop(it)
        it+=1
    '''
    # post-analyse: context-dependent part
    print "LOG: final stack dump before top-down walk"
    for i in xrange(0, len(parser.stack.data)):
        print str(i) + ": " + str(parser.stack.data[i])

    it = 0
    '''
    while it < parser.stack.sp:
        it += 1
        if routines.is_link(parser.stack[it]):
            parser.stack.bp = parser.stack[it]
            while
    '''



parse("1 1 1 [ 2 2 2 [ 3 3 2 [ ] ] 5 5 5 [ ] 6 6 5 [ ] ]")