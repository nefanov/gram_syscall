# coding=utf-8
import sys
import routines
from orderedset import OrderedSet
from ordereddict import OrderedDict


#  rule checkers

class proc:

    def __init__(self, p, g, s):
        self.g = g
        self.s = s
        self.p = p


# every match function returns list of [the name [args] of syscall, reconstructed Left side of rule (proc-terminal)]
# for example, ['fork', [1,1,1]]


def match_fork(p=proc('1','1','1'), c=proc('1','1','1')):
    if p.g == c.g and p.s == c.s:
        return ['fork', [p.p, p.g, p.s]]
    return ['nop', []]


def match_fork_adapter(parent=['1','1','1'], child=['1','1','1']):
    print "match fork adapter: log debug: parent: " + str(parent) + "match" + str(child)
    return match_fork(proc(parent[0],parent[1],parent[2]), proc(child[0],child[1],child[2]))


#context-dependent check: session with c.s number should exist

def match_setsid(p=proc('1', '1', '1'), c=proc('1', '1', '1'), context_dep=False, data_list=[OrderedSet(), OrderedSet()]):
    if c.s == c.g == c.p:
        if not c.s == p.s:
            data_list[0].add(c.s)
            data_list[1].add(c.s) # group with the same number exists too
            return ['setsid', [c.p, p.g, p.s]]

    if not context_dep==False:
        if not c.s == p.s and not c.g in data_list[0]:
            print "parsing error: session "+str(c.s)+" not found"
            quit()

    return ['nop', []]


# setpgid is context-dependent rule
def match_setpgid(p=proc('1', '1', '1'), c=proc('1', '1', '1'), context_dep=False, data_list=[OrderedSet(), OrderedSet()]):
    # the most simple case: setpgid(0,0) - set new group and become group leader
    if c.p == c.g and not c.s == c.p:
        data_list[1].add(c.g)
        return ['setpgid('+ str(c.g) + ', ' + str(c.g)+')', [c.p, p.g, c.s]]

    # the another case is more complex and context-dependent: the group should be checked: setpgid(0,pgid) && exists(pgid,pgid,sid)
    #  - add itself to some group

    if not context_dep==False:
        if not c.g in data_list[1]:
            print "parsing error: group "+str(c.g)+" not exists!"
            quit()
         # else
        if not c.g == p.g:
            print "triggered cd setpgid"
            if c.s == p.s:
                print "triggered correct"
                return ['setpgid(self,' + p.s + ')', [c.p, p.g, c.s]]
    print "exit from " + str(p.p) + ' ' + str(p.g) + ' ' + str(p.s) + '       ' + str(c.p) + ' ' + str(c.g) + ' ' + str(c.s)
    return ['nop', []]

#context-dependent patterns match
# child: left-side only
# parent_list: whole process transformation chain
# lookup_data: context: now list of OrderedSets
# взять все родительские состояния, жадным поиском с сопоставлением КЗ-правила дополнить ребёнка слева до форка от любого из них
def cd_patterns_match(parent_list=[['1','1','1']], child=['2','1','1'], lookup_data=[]):

    for parent in parent_list:
        print 'cd_match:' + str(parent) + ' ' + str(child)
        if routines.is_basestring(parent):
            continue
        p = proc(parent[0], parent[1], parent[2])
        c = proc(child[0], child[1], child[2])
        proc_rules_list = [match_setsid, match_setpgid]
        for i, func in enumerate(proc_rules_list):
            subres = func(p, c, True, lookup_data)
            if subres[0] != 'nop':
                return subres

    return ['nop', []]

#  context-free patterns match
def cf_patterns_match(parent=['1','1','1'], child=['2','1','1'], lookup_data=[] ):
    p = proc(parent[0], parent[1], parent[2])
    c = proc(child[0], child[1], child[2])
    proc_rules_list = [match_setsid, match_setpgid]
    for i, func in enumerate(proc_rules_list):
        if func(p, c, False, lookup_data)[0] != 'nop':
            return func(p, c)

    return ['nop', []]

'''
# put context-dependent part here !
'''


# terminal->nonterminal stack
# bp, sp, lr are indexes, lr are unused now
class stack:

    def __init__(self):
        self.bp = 0
        self.sp = 0
        self.lr = 0
        self.data = list()

    def __getitem__(self, item):
        return self.data[item]

    def __setitem__(self, key, value):
        self.data[key] = value


# push the val to analyser's stack
    def push(self, val):
        self.data.append(val)
        self.sp += 1

# pop the val and return, without bp unwinding
    def pop(self):
        self.sp -= 1
        return self.data.pop()

# call: save the bp into lr and
    def call(self):
        self.lr = self.bp
        self.bp = self.sp

# unwind the bp
    def unwind(self):
        self.bp = self.lr
'''
    def represent(self,  children_from, parent=routines.Node("1 1 1")):
        for i in xrange(children_from, len(parent.data)):
'''



#def match_pattern(, ):


class machine:

    def __init__(self):
        self.stack = stack()
        self.state = 'init'
        self.pidset = OrderedSet()
        self.sidset = OrderedSet()
        self.pgidset = OrderedSet()
        self.linker = OrderedDict() # link the nodes: key (stack index) : [parent stack index, index of parent's state]

#


def cd_down(parser, it, sp):
    while it < sp - 1: # from start to the bottom of the stack
        it += 1

        if routines.is_link(parser.stack[it]):

            for link in parser.stack[it][1]: # go through the all of 1st children


                match_res = cd_patterns_match(parser.stack[it - 1], parser.stack[link - 1][0], [parser.sidset, parser.pgidset])

                if not match_res[0] == 'nop':
                    # apply the matched pattern: left side of rule reconstruction
                    print "\t match OK: " + str(match_res[0]) + str(match_res[1])
                    parser.stack[link-1].insert(0, match_res[0])
                    parser.stack[link-1].insert(0, match_res[1])

#attach: checker & linker:

                for node in parser.stack[it-1]: # go through the states of parent
                    if routines.is_basestring(node):
                        continue

                    subres = match_fork_adapter(node, parser.stack[link-1][0])
                    if subres[0] == 'fork':
                        print "CURRENT PARENT IS FOUND"

                        parser.linker[parser.stack.data.index(parser.stack[link-1])] =  [it-1 , parser.stack[it-1].index(node)]
                        break

                    if node == parser.stack[it-1][-1] and subres[0] == 'nop':
                        print "Parsing error: string is incorrect (troubles with " + str(node) + " and " + str(parser.stack[link-1][0])
                        quit()

            if not len(parser.stack[it][1]): # the leaf-node
                continue

    # then return
    return

def tree_visualize(parser, root, ptree_storage=OrderedDict()):
    for i in parser.linker.keys():
        right = routines.Node(str(parser.stack[i][0]), parent=ptree_storage[parser.linker[i][0]][parser.linker[i][1]/2])
        ptree_storage[i] = [right]

        for j in xrange(2, len(parser.stack[i])):
            if routines.is_basestring(parser.stack[i][j]):
                continue
            right = routines.Node(str(parser.stack[i][j-1])+ "->" + str(parser.stack[i][j]), parent=right)
            ptree_storage[i].append(right)

    return root

# parser is a left context-free parser with context-dependent post-check (In compiler-like SA manner).
# 1) context-free upwarding until ']' with non-empty stack. Then trusted (context-free) downwarding on stackframe with reconstruction.
# 2) after the whole string is ended - full untrusted (context-dependent) process check.

#'optimized' should solve the problem of non-optimal setpgids (see example 1 1 1 -> 2 2 1 -> 3 1 1)


def parse(argst="100 101 102 [ ]", optimized=False):
    line = argst.split(' ')

    parser = machine()

    num = 0
    while num in xrange(len(line)):
        if (line[num]).isdigit() and (line[num+1]).isdigit() and (line[num+2]).isdigit():
            parser.state = 'proc'
            parser.stack.push([[line[num], line[num+1], line[num+2]]])
            num += 3

            try:
                parser.pidset.index(int(line[num-3]))
            except ValueError:
                parser.pidset.add(int(line[num-3]))

            else:
                print "Parsing error: pid duplicate"
                break

        if line[num] == '[':
            if parser.state == 'proc':
                parser.state = 'call'
                parser.stack.push([parser.stack.bp])
                parser.stack[-1].append([])
#                print "bp_old" + str(parser.stack.bp)
#                print "bp_new" + str(parser.stack.sp - 1)
#                print parser.stack.data
                parser.stack.bp = parser.stack.sp - 1

        elif line[num] == ']':

            if parser.stack.sp - parser.stack.bp == 1:  # leaf-node

                parser.state == 'revert'

                parser.stack.bp = parser.stack[parser.stack.bp][0]

                num += 1
                continue

            else:

                #  not leaf node - visit all of 1st level children
                it = parser.stack.bp
                while it < parser.stack.sp - 1:

                    it += 1

                    print it
                    # check all context rules, then:
                    if not (routines.is_link(parser.stack[it])):
                        inner_it = -1
                        if parser.stack[it+1][0] > parser.stack.bp:
                            it += 1
                            continue
                        #else append the children's basepointers into the list near the parent basepointer
                        # (to handle them in context-dependent downward)
                        parser.stack[parser.stack.bp][1].append(it+1)
                        # log info:
                        print "match " + str(parser.stack[parser.stack.bp-1][inner_it])+" and "+str(parser.stack[it][inner_it])
                        match_res = cf_patterns_match(parser.stack[parser.stack.bp-1][inner_it], parser.stack[it][inner_it], [parser.sidset, parser.pgidset])
                        # insert the reconstructed part into the stack on the current child position (left-side)

                        if not match_res[0] == 'nop':
                            # apply the matched pattern: left side of rule reconstruction
                            print "\t match OK: "+str(match_res[0]) + str(match_res[1])
                            parser.stack[it].insert(0, match_res[0])
                            parser.stack[it].insert(0, match_res[1])

                    else:
                        continue

                parser.state == 'revert'
                parser.stack.bp = parser.stack[parser.stack.bp][0]

        else:
            print "Parsing error: " + line[num]
            break

        num += 1

    # post-analyse: context-dependent part
    print "LOG debug: final stack dump before top-down walk"
    for i in xrange(0, len(parser.stack.data)):
        print str(i) + ": " + str(parser.stack.data[i])

    print "LOG debug: pgroups: " + str(parser.pgidset)
    print "LOG debug: sessions: " + str(parser.sidset)
    it = 0

    print "Context-dependent part"

    ptree_root = routines.Node(str(parser.stack[0][0]), parser.stack[0][0][0], parser.stack[0][0][1], parser.stack[0][0][2])
    parser.sidset.add(parser.stack[0][0][2])
    parser.pgidset.add(parser.stack[0][0][1])
    cd_down(parser, 0, parser.stack.sp)
    routines.log_output(ptree_root, "", 1, 0)
    print parser.linker
    # post-print of stack:
    for i in xrange(0, len(parser.stack.data)):
        print str(i) + ": " + str(parser.stack.data[i])
    print "STREE_VISUALIZE(): "
    root = routines.Node("['1','1','1']", parent=None)

    ptree_tmp = OrderedDict()
    ptree_tmp[0] = [root]
    res = tree_visualize(parser, root, ptree_tmp)
    print "TEST TREE:"
    routines.log_output(root, "", 1, 0)

parse("1 1 1 [ 2 2 2 [ 3 3 2 [ 6 2 2 [ 7 3 2 [ ] ] ] ] 5 5 5 [ 10 5 1 [ ] ] ]")  # 6 6 5 [ ] ]")  # 6 6 5 [ ] ]")