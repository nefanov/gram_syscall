import os
import routines
from orderedset import OrderedSet


#  rule checkers

class proc:

    def __init__(self,p,g,s):
        self.g = g
        self.s = s
        self.p = p


def match_fork(p=proc('1','1','1'), c=proc('1','1','1')):
    if p.g == c.g == p.s == c.s:
        return 'fork'
    return 'nop'


def match_setsid(p=proc('1','1','1'), c=proc('1','1','1')):
    if c.s == c.g == c.p:
        if not c.s == p.s:
            return 'setsid'

    return 'nop'


# setpgid is context-dependent rule
def match_setpgid(p=proc('1','1','1'), c=proc('1','1','1'), context_dep=False, group_list=[]):
    # the most simple case: setpgid(0,0)
    if c.g == c.p and not c.s == c.p:
        return 'setpgid(0,0)'

    # the another case is more complex and context-dependent: the group should be checked: setpgid(0,pgid) && exists(pgid,pgid,sid)
    if context_dep:
        if c.g in group_list and not c.g == p.g and c.s == p.s:
            return 'setpgid(0,' + p.s + ')'

    return 'nop'


#  context-free patterns match
def cf_patterns_match(parent=['1','1','1'], child=['2','1','1']):
    p = proc(parent[0],parent[1],parent[2])
    c = proc(child[0], child[1], child[2])
    proc_rules_list = [match_setsid, match_setpgid]
    for func in proc_rules_list:
        if func(p, c) != 'nop':
            return func(p, c)
    return 'nop'


def reconstruct(proc_chain=[]):

    return proc_chain

'''
def attach(list ):

    return Node
'''


# terminal->nonterminal stack
# bp, sp, lr are indexes, lr are unused now
class stack:

    def __init__(self):
        self.bp = 0
        self.sp = 0
        self.lr = 0
        self.data = list()

    def __getitem__(self,item):
        return self.data[item]

    def __setitem__(self, key, value):
        self.data[key] = value


# push the val to analyser's stack
    def push(self, val):
        self.data.append(val)
        self.sp += 1

# pop the val and return, without bp unwinding
    def pop(self):
        self.sp -= 1
        return self.data.pop()

# call: save the bp into lr and
    def call(self):
        self.lr = self.bp
        self.bp = self.sp

# unwind the bp
    def unwind(self):
        self.bp = self.lr
'''
    def represent(self,  children_from, parent=routines.Node("1 1 1")):
        for i in xrange(children_from, len(parent.data)):
'''



#def match_pattern(, ):


class machine:

    def __init__(self):
        self.stack = stack()
        self.state = 'init'


# parser is a left context-free parser with context-dependent post-check (In compiler-like SA manner).
# 1) context-free upwarding until ']' with non-empty stack. Then trusted (context-free) downwarding on stackframe with reconstruction.
# 2) after the whole string is ended - full untrusted (context-dependent) process check.


def parse(argst="100 101 102 [ ]"):
    line = argst.split(' ')
    pidset = OrderedSet()
    parser = machine()

    num = 0
    while num in xrange(len(line)):
        if (line[num]).isdigit() and (line[num+1]).isdigit() and (line[num+2]).isdigit():
            parser.state = 'proc'
            parser.stack.push([[line[num], line[num+1], line[num+2]]]) #list of lists
            num += 3

            try:
                pidset.index(int(line[num-3]))
            except ValueError:
                pidset.add(int(line[num-3]))

            else:
                print "Parsing error: pid duplicate"
                break

        if line[num] == '[':
            if parser.state == 'proc':
                parser.state = 'call'
                parser.stack.push(parser.stack.bp)
#                print "bp_old" + str(parser.stack.bp)
#                print "bp_new" + str(parser.stack.sp - 1)
#                print parser.stack.data
                parser.stack.bp = parser.stack.sp - 1

        elif line[num] == ']':

            if parser.stack.sp - parser.stack.bp == 1:  # leaf-node

                parser.state == 'revert'

                parser.stack.bp = parser.stack[parser.stack.bp]

                num += 1
                continue

            else:

                #  not the leaf node
                for it in xrange(parser.stack.bp + 1, parser.stack.sp, 1):

                    # check all context rules, then:
                    if  not (routines.is_link(parser.stack[it])):
                        inner_it = -1
                        match_res = cf_patterns_match(parser.stack[parser.stack.bp-1][inner_it], parser.stack[it][inner_it])
                        if not match_res == 'nop':
                            print match_res
                            print parser.stack[it], "<-", parser.stack[parser.stack.bp-1]
                            parser.stack[it].insert(0,match_res)
                            print "pbp"
                            print parser.stack[parser.stack.bp - 1]
                            parser.stack[it].insert(0, [parser.stack[it][-1][0], parser.stack[parser.stack.bp-1][-1][1], parser.stack[parser.stack.bp-1][-1][2]])
#                            parser.stack[it][0][0] = parser.stack[it][-1][0]
                            print it


                    else:
#                        parser.stack[it] = -1
                        continue

                parser.state == 'revert'
                parser.stack.bp = parser.stack[parser.stack.bp]

        else:
            print "Parsing error: " + line[num]
            break

        num += 1
    '''
    it = 0
    while it < len(parser.stack.data):
        if parser.stack.data[it] == -1:
            parser.stack.data.pop(it)
        it+=1
    '''
    # post-analyse: context-dependent part
    print "final stack dump"
    for i in parser.stack.data:
        print i



parse("1 1 1 [ 2 2 2 [ 4 1 1 [ ] 6 6 1 [ ] ] 5 1 1 [ ] ]")