1 1 1 [ 11 1 1 [ 13 1 1 [ ] ] 2 2 5 [ ] ] #simple exit: session not exists

1 1 1 [ 5 4 3 [ ] 3 3 3 [ 4 4 3 [ ] ] ] # no exited in session

1 1 1 [ 6 5 5 [ ] 8 6 5 [ ] ] # exits in session

                                # но ещё нужно проверить группу: если p!=pg и такая группа уже есть в отличной сессии - parsing warning:
                                # нужна доп. проверка непройденных детей: многие из них могут стать групп-лидерами в той же сессии
                                # станут - можно будет сделать реверсный реперент, не станут  - нельзя
                                # поэтому реализуем логику с картинки
                                # if !sg_mesh[g]
                                # !!! Логика нижележащей строки уже покрыта восходящим разбором: сессию добавляет только её лидер
                                # !!! for lookup in laydown_init_children:
                                # !!! if g==p && g.s == S(p) -> ok;
                                # аналогично если нет exit, но там аттач к подходящему в нужной сессии
                                # правильность сессии обеспечивает то что setsid можно сделать только 1 раз

                                # разворачивание в стеке не аффектит данные о сессиях и группах, поэтому можно добавить(если что - для отладки)
                                # на данном шаге нас интересует только терминальное состояние ребёнка, которому восстанавливаем родителя:
                                # остальное - проверить и решить, нужен ли setpgid